import { serve } from "https://deno.land/std@0.190.0/http/server.ts";
import { createClient } from "https://esm.sh/@supabase/supabase-js@2";

// =====================================================
// Dealer Notification Rules Evaluator (INLINE)
// =====================================================

export interface DealerNotificationRule {
  id: string;
  dealer_id: number;
  module: string;
  event: string;
  rule_name: string;
  description: string;
  recipients: {
    roles?: string[];
    users?: string[];
    include_assigned_user?: boolean;
    include_followers?: boolean;
  };
  conditions: {
    priority?: string[];
    status?: string[];
    custom_fields?: Record<string, any>;
  };
  channels: string[];
  priority: number;
  enabled: boolean;
}

function evaluateRuleConditions(
  conditions: DealerNotificationRule['conditions'],
  eventData: any
): boolean {
  if (!conditions || Object.keys(conditions).length === 0) {
    return true;
  }

  if (conditions.priority && conditions.priority.length > 0) {
    const eventPriority = eventData.priority || eventData.newPriority;
    if (!eventPriority || !conditions.priority.includes(eventPriority)) {
      console.log(`‚ùå Priority condition not met: event=${eventPriority}, allowed=[${conditions.priority.join(', ')}]`);
      return false;
    }
    console.log(`‚úÖ Priority condition met: ${eventPriority}`);
  }

  if (conditions.status && conditions.status.length > 0) {
    const eventStatus = eventData.status || eventData.newStatus;
    if (!eventStatus || !conditions.status.includes(eventStatus)) {
      console.log(`‚ùå Status condition not met: event=${eventStatus}, allowed=[${conditions.status.join(', ')}]`);
      return false;
    }
    console.log(`‚úÖ Status condition met: ${eventStatus}`);
  }

  if (conditions.custom_fields) {
    for (const [fieldName, expectedValue] of Object.entries(conditions.custom_fields)) {
      const actualValue = eventData[fieldName];
      if (Array.isArray(expectedValue)) {
        if (!expectedValue.includes(actualValue)) {
          console.log(`‚ùå Custom field condition not met: ${fieldName}=${actualValue}, allowed=[${expectedValue.join(', ')}]`);
          return false;
        }
      } else if (actualValue !== expectedValue) {
        console.log(`‚ùå Custom field condition not met: ${fieldName}=${actualValue}, expected=${expectedValue}`);
        return false;
      }
      console.log(`‚úÖ Custom field condition met: ${fieldName}=${actualValue}`);
    }
  }

  return true;
}

function filterUsersByRule(
  rule: DealerNotificationRule,
  users: Array<{ id: string; role_name?: string; is_assigned?: boolean }>
): typeof users {
  const { recipients } = rule;
  if (!recipients || Object.keys(recipients).length === 0) {
    return users;
  }

  return users.filter(user => {
    if (recipients.roles && recipients.roles.length > 0) {
      if (!user.role_name || !recipients.roles.includes(user.role_name)) {
        console.log(`‚ùå User filtered out by role: ${user.id} (role: ${user.role_name})`);
        return false;
      }
    }

    if (recipients.users && recipients.users.length > 0) {
      if (!recipients.users.includes(user.id)) {
        console.log(`‚ùå User filtered out by user list: ${user.id}`);
        return false;
      }
    }

    if (recipients.include_assigned_user === false && user.is_assigned === true) {
      console.log(`‚ùå User filtered out: assigned user excluded by rule`);
      return false;
    }

    console.log(`‚úÖ User passed rule filters: ${user.id}`);
    return true;
  });
}

function isChannelEnabled(rule: DealerNotificationRule, channel: string): boolean {
  if (!rule.channels || rule.channels.length === 0) {
    return true;
  }
  return rule.channels.includes(channel);
}

function findMatchingRule(
  rules: DealerNotificationRule[],
  module: string,
  event: string,
  eventData: any
): DealerNotificationRule | null {
  const applicableRules = rules.filter(rule =>
    rule.enabled &&
    rule.module === module &&
    rule.event === event &&
    evaluateRuleConditions(rule.conditions, eventData)
  );

  if (applicableRules.length === 0) {
    console.log(`‚ÑπÔ∏è No matching dealer rules found for ${module}/${event}`);
    return null;
  }

  applicableRules.sort((a, b) => b.priority - a.priority);
  const topRule = applicableRules[0];
  console.log(`‚úÖ Found matching dealer rule: "${topRule.rule_name}" (priority: ${topRule.priority})`);
  return topRule;
}

function evaluateNotificationRule(
  rule: DealerNotificationRule | null,
  users: Array<{ id: string; role_name?: string; is_assigned?: boolean }>,
  channel: string,
  eventData: any
): { shouldSend: boolean; filteredUsers: typeof users; rule: DealerNotificationRule | null } {
  if (!rule) {
    return { shouldSend: true, filteredUsers: users, rule: null };
  }

  if (!isChannelEnabled(rule, channel)) {
    console.log(`‚ùå Channel "${channel}" not enabled in dealer rule "${rule.rule_name}"`);
    return { shouldSend: false, filteredUsers: [], rule };
  }

  const filteredUsers = filterUsersByRule(rule, users);
  console.log(`‚úÖ Dealer rule applied: ${users.length} users ‚Üí ${filteredUsers.length} after filtering`);

  return {
    shouldSend: filteredUsers.length > 0,
    filteredUsers,
    rule
  };
}

// =====================================================
// Main SMS Notification System
// =====================================================

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
  'Access-Control-Allow-Methods': 'POST, OPTIONS'
};

const supabaseUrl = Deno.env.get('SUPABASE_URL')!;
const supabaseServiceKey = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')!;
const twilioAccountSid = Deno.env.get('TWILIO_ACCOUNT_SID');
const twilioAuthToken = Deno.env.get('TWILIO_AUTH_TOKEN');
const twilioPhoneNumber = Deno.env.get('TWILIO_PHONE_NUMBER');

const supabase = createClient(supabaseUrl, supabaseServiceKey);

type OrderSMSEvent =
  | 'order_created'
  | 'order_assigned'
  | 'status_changed'
  | 'field_updated'
  | 'comment_added'
  | 'attachment_added'
  | 'follower_added'
  | 'due_date_approaching'
  | 'overdue'
  | 'priority_changed';

interface SMSNotificationRequest {
  orderId: string;
  dealerId: number;
  module: 'sales_orders' | 'service_orders' | 'recon_orders' | 'car_wash';
  eventType: OrderSMSEvent;
  eventData: {
    orderNumber: string;
    stockNumber?: string;
    tag?: string;
    customerName?: string;
    vehicleInfo?: string;
    shortLink?: string;
    newStatus?: string;
    oldStatus?: string;
    fieldName?: string;
    oldValue?: string;
    newValue?: string;
    assignedToUserId?: string;
    assignedToName?: string;
    commentText?: string;
    commenterName?: string;
    minutesUntilDue?: number;
    dueDateTime?: string;
    newPriority?: string;
    oldPriority?: string;
  };
  triggeredBy?: string;
}

interface SMSRecipient {
  id: string;
  name: string;
  phone_number: string;
  role_name?: string;
  notification_level?: 'all' | 'important' | 'none';
}

interface SMSPreferences {
  user_id: string;
  event_preferences: any;
  max_sms_per_hour: number;
  max_sms_per_day: number;
  quiet_hours_enabled: boolean;
  quiet_hours_start: string;
  quiet_hours_end: string;
}

async function createDefaultSMSPreferences(
  userId: string,
  dealerId: number,
  module: string
): Promise<SMSPreferences | null> {
  console.log(`   üÜï Auto-creating default SMS preferences for user ${userId}`);

  const defaultPreferences = {
    user_id: userId,
    dealer_id: dealerId,
    module: module,
    sms_enabled: false,
    phone_number: null,
    event_preferences: {},
    max_sms_per_hour: 10,
    max_sms_per_day: 50,
    quiet_hours_enabled: false,
    quiet_hours_start: '22:00',
    quiet_hours_end: '08:00'
  };

  const { data, error } = await supabase
    .from('user_sms_notification_preferences')
    .insert(defaultPreferences)
    .select()
    .single();

  if (error) {
    console.error(`   ‚ùå Failed to create default preferences:`, error);
    return null;
  }

  console.log(`   ‚úÖ Default preferences created successfully`);
  return data as SMSPreferences;
}

const handler = async (req: Request): Promise<Response> => {
  if (req.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders });
  }

  try {
    if (!twilioAccountSid || !twilioAuthToken || !twilioPhoneNumber) {
      throw new Error('Twilio credentials not configured');
    }

    const request: SMSNotificationRequest = await req.json();
    const requestId = Date.now(); // Unique ID for tracking this request

    console.log(`\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ`);
    console.log(`üÜî [REQUEST ${requestId}] START`);
    console.log(`üì± SMS Notification Request:`, request);
    console.log(`üîç Trigger user: ${request.triggeredBy}`);
    console.log(`‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n`);

    // LEVEL 4 DISABLED: Dealer notification rules validation removed
    // System now only uses 3-level validation (Follower ‚Üí Role ‚Üí Preferences)
    // To re-enable: Uncomment checkNotificationRules() and applyDealerNotificationRules()

    console.log(`üîê [${requestId}] Starting 3-level validation for order ${request.orderId}`);
    const eligibleUsers = await getUsersEligibleForNotification(
      request.dealerId,
      request.module,
      request.orderId,
      request.eventType,
      request.eventData
    );
    console.log(`\n‚úÖ [${requestId}] 3-LEVEL VALIDATION COMPLETE: ${eligibleUsers.length} eligible users`);
    console.log(`üîç [${requestId}] Eligible users:`, eligibleUsers.map(u => ({ id: u.id, name: u.name, phone: u.phone_number })));

    if (eligibleUsers.length === 0) {
      console.log(`‚ö†Ô∏è [${requestId}] NO ELIGIBLE USERS - Returning 0 sent`);
      return new Response(
        JSON.stringify({
          success: true,
          sent: 0,
          failed: 0,
          recipients: 0,
          message: 'No eligible users after 3-level validation (follower + role + preferences)'
        }),
        { headers: { 'Content-Type': 'application/json', ...corsHeaders } }
      );
    }

    // LEVEL 4 DISABLED: Dealer notification rules removed
    // Using eligibleUsers directly (skip dealer rules filtering)
    const usersAfterDealerRules = eligibleUsers;
    console.log(`üìã [${requestId}] LEVEL 4 SKIPPED (disabled): ${usersAfterDealerRules.length} users pass through`);

    const usersAfterRateLimit = await checkRateLimits(usersAfterDealerRules, request.dealerId, request.module);
    console.log(`‚è±Ô∏è After rate limit check: ${usersAfterRateLimit.length} users`);
    console.log(`üîç [DEBUG] Users after rate limit:`, usersAfterRateLimit.map(u => ({ id: u.id, name: u.name })));

    if (usersAfterRateLimit.length === 0) {
      return new Response(
        JSON.stringify({
          success: true,
          sent: 0,
          failed: 0,
          recipients: usersAfterDealerRules.length,
          message: 'All users hit rate limits'
        }),
        { headers: { 'Content-Type': 'application/json', ...corsHeaders } }
      );
    }

    const finalUsers = usersAfterRateLimit.filter(u => u.id !== request.triggeredBy);
    console.log(`\nüë§ [${requestId}] SELF-EXCLUSION CHECK:`);
    console.log(`   Before: ${usersAfterRateLimit.length} users`);
    console.log(`   Trigger user: ${request.triggeredBy}`);
    console.log(`   After: ${finalUsers.length} users (excluded ${usersAfterRateLimit.length - finalUsers.length})`);

    if (finalUsers.length === 0) {
      console.log(`‚ö†Ô∏è [${requestId}] ONLY TRIGGER USER - Returning 0 sent\n`);
      return new Response(
        JSON.stringify({
          success: true,
          sent: 0,
          failed: 0,
          recipients: usersAfterRateLimit.length,
          message: 'Only trigger user would receive notification'
        }),
        { headers: { 'Content-Type': 'application/json', ...corsHeaders } }
      );
    }

    console.log(`\nüí¨ [${requestId}] GENERATING MESSAGES...`);
    const messages = generateMessages(finalUsers, request.eventType, request.eventData);
    console.log(`‚úÖ [${requestId}] Generated ${messages.length} messages`);
    messages.forEach(({ user, message }) => {
      console.log(`   ‚Üí ${user.name} (${user.phone_number}): ${message.substring(0, 80)}...`);
    });

    console.log(`\nüì§ [${requestId}] SENDING SMS VIA TWILIO...`);
    const results = await Promise.allSettled(
      messages.map(({ user, message }) =>
        sendSMS(user.phone_number, message, request.orderId)
      )
    );

    console.log(`\nüíæ [${requestId}] RECORDING TO sms_send_history...`);
    await recordSMSHistory(
      results,
      finalUsers,
      messages,
      request.dealerId,
      request.module,
      request.eventType,
      request.orderId
    );

    const successCount = results.filter(r => r.status === 'fulfilled').length;
    const failedCount = results.filter(r => r.status === 'rejected').length;
    const recipientNames = finalUsers.map(u => u.name);

    console.log(`\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ`);
    console.log(`‚úÖ [${requestId}] REQUEST COMPLETE`);
    console.log(`üìä Summary: ${successCount} sent, ${failedCount} failed`);
    console.log(`üë• Recipients: ${recipientNames.join(', ')}`);
    console.log(`‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n`);

    return new Response(
      JSON.stringify({
        success: true,
        sent: successCount,
        failed: failedCount,
        recipients: finalUsers.length,
        recipientNames: recipientNames
      }),
      {
        status: 200,
        headers: { 'Content-Type': 'application/json', ...corsHeaders }
      }
    );

  } catch (error: any) {
    console.error('‚ùå SMS Notification Error:', error);
    return new Response(
      JSON.stringify({ success: false, error: error.message }),
      {
        status: 500,
        headers: { 'Content-Type': 'application/json', ...corsHeaders }
      }
    );
  }
};

async function checkNotificationRules(
  dealerId: number,
  module: string,
  eventType: string
): Promise<boolean> {
  const { data, error } = await supabase
    .from('dealer_notification_rules')
    .select('id')
    .eq('dealer_id', dealerId)
    .eq('module', module)
    .eq('event', eventType)
    .eq('enabled', true)
    .contains('channels', ['sms']);

  if (error) {
    console.error('[checkNotificationRules] Error querying dealer_notification_rules:', error);
    return true;
  }

  const isEnabled = (data && data.length > 0);
  console.log(`[checkNotificationRules] Event "${eventType}" for module "${module}": ${isEnabled ? 'ENABLED' : 'DISABLED'} (${data?.length || 0} rules found)`);
  return isEnabled;
}

async function getUsersEligibleForNotification(
  dealerId: number,
  module: string,
  orderId: string,
  eventType: OrderSMSEvent,
  eventData: any
): Promise<SMSRecipient[]> {

  console.log(`\nüîç === STARTING 3-LEVEL VALIDATION ===`);
  console.log(`Order: ${orderId}, Event: ${eventType}, Module: ${module}`);

  console.log(`\n1Ô∏è‚É£ LEVEL 1: Fetching FOLLOWERS of order ${orderId}...`);

  const { data: followers, error: followersError } = await supabase
    .from('entity_followers')
    .select(`
      user_id,
      notification_level,
      dealer_id,
      profiles!inner(
        id,
        first_name,
        last_name,
        phone_number,
        dealer_memberships!inner(
          is_active,
          custom_role_id,
          dealer_id,
          dealer_custom_roles!inner(
            id,
            role_name
          )
        )
      )
    `)
    .eq('entity_type', 'order')
    .eq('entity_id', orderId)
    .eq('is_active', true)
    .neq('notification_level', 'none')
    .eq('dealer_id', dealerId)
    .eq('profiles.dealer_memberships.is_active', true)
    .eq('profiles.dealer_memberships.dealer_id', dealerId)
    .not('profiles.phone_number', 'is', null);

  if (followersError) {
    console.error('‚ùå Error fetching followers:', followersError);
    return [];
  }

  if (!followers || followers.length === 0) {
    console.log(`‚ö†Ô∏è No followers found for order ${orderId}`);
    return [];
  }

  console.log(`‚úÖ LEVEL 1 PASSED: Found ${followers.length} followers`);
  followers.forEach(f => {
    const membership = f.profiles.dealer_memberships?.[0];
    const roleName = membership?.dealer_custom_roles?.role_name || 'Unknown';
    console.log(`   - ${f.profiles.first_name} ${f.profiles.last_name} (${roleName})`);
  });

  console.log(`\n2Ô∏è‚É£ 3Ô∏è‚É£ LEVEL 2 & 3: Validating ROLE permissions and USER preferences...`);

  const eligibleUsers: SMSRecipient[] = [];

  for (const follower of followers) {
    const userId = follower.profiles.id;
    const membership = follower.profiles.dealer_memberships?.[0];

    if (!membership) {
      console.warn(`   ‚ö†Ô∏è No dealer membership found for user ${userId}, skipping`);
      continue;
    }

    const roleId = membership.custom_role_id;
    const roleName = membership.dealer_custom_roles?.role_name || 'Unknown';
    const userName = `${follower.profiles.first_name} ${follower.profiles.last_name}`;

    console.log(`\n   Checking user: ${userName} (Role: ${roleName})`);

    const { data: roleEventConfig, error: roleEventError } = await supabase
      .from('role_notification_events')
      .select('*')
      .eq('role_id', roleId)
      .eq('module', module)
      .eq('event_type', eventType)
      .eq('enabled', true)
      .single();

    if (roleEventError || !roleEventConfig) {
      console.log(`   ‚ùå LEVEL 2 FAILED: Role "${roleName}" does NOT allow event "${eventType}"`);
      continue;
    }

    console.log(`   ‚úÖ LEVEL 2 PASSED: Role "${roleName}" allows event "${eventType}"`);

    if (eventType === 'status_changed') {
      const allowedStatuses = roleEventConfig.event_config?.allowed_statuses || [];

      if (allowedStatuses.length > 0 && !allowedStatuses.includes(eventData.newStatus)) {
        console.log(`   ‚ùå Status "${eventData.newStatus}" not in role's allowed list: [${allowedStatuses.join(', ')}]`);
        continue;
      }

      console.log(`   ‚úÖ Status "${eventData.newStatus}" is allowed by role`);
    }

    console.log(`   3Ô∏è‚É£ LEVEL 3: Checking USER preferences...`);

    let { data: userPrefs, error: userPrefsError } = await supabase
      .from('user_sms_notification_preferences')
      .select('*')
      .eq('user_id', userId)
      .eq('dealer_id', dealerId)
      .eq('module', module)
      .single();

    if (userPrefsError || !userPrefs) {
      console.log(`   ‚ö†Ô∏è User has no notification preferences set`);
      userPrefs = await createDefaultSMSPreferences(userId, dealerId, module);

      if (!userPrefs) {
        console.log(`   ‚ùå Failed to create default preferences, skipping user`);
        continue;
      }
    }

    if (!userPrefs.sms_enabled) {
      console.log(`   ‚ùå LEVEL 3 FAILED: User has SMS globally disabled`);
      continue;
    }

    // SIMPLIFIED VALIDATION: Only check global sms_enabled toggle
    // event_preferences removed - events controlled exclusively by Custom Roles (Level 2)
    // BREAKING CHANGE: Existing event_preferences are now ignored
    console.log(`   ‚úÖ LEVEL 3 PASSED: User has SMS globally enabled (event_preferences ignored)`);

    if (follower.notification_level === 'important') {
      const importantEvents: OrderSMSEvent[] = [
        'order_assigned',
        'status_changed',
        'due_date_approaching',
        'overdue',
        'priority_changed'
      ];

      if (!importantEvents.includes(eventType)) {
        console.log(`   ‚ö†Ô∏è User has notification_level='important', skipping non-important event`);
        continue;
      }
    }

    eligibleUsers.push({
      id: userId,
      name: userName,
      phone_number: follower.profiles.phone_number,
      role_name: roleName,
      notification_level: follower.notification_level
    });

    console.log(`   ‚úÖ‚úÖ‚úÖ USER ELIGIBLE: ${userName}`);
  }

  console.log(`\nüéØ === VALIDATION COMPLETE ===`);
  console.log(`Total eligible users: ${eligibleUsers.length} out of ${followers.length} followers`);

  return eligibleUsers;
}

async function applyDealerNotificationRules(
  users: SMSRecipient[],
  dealerId: number,
  module: string,
  eventType: string,
  eventData: any
): Promise<SMSRecipient[]> {
  try {
    console.log(`\nüìã === LEVEL 4 (OPTIONAL): DEALER NOTIFICATION RULES ===`);
    console.log(`Checking for dealer-configured rules for ${module}/${eventType}...`);

    const { data: rules, error: rulesError } = await supabase
      .from('dealer_notification_rules')
      .select('*')
      .eq('dealer_id', dealerId)
      .eq('module', module)
      .eq('event', eventType)
      .eq('enabled', true)
      .order('priority', { ascending: false });

    if (rulesError) {
      console.warn(`‚ö†Ô∏è Error querying dealer_notification_rules (continuing without rules):`, rulesError.message);
      console.log(`‚úÖ Skipping dealer rules due to error - all ${users.length} users pass through`);
      return users;
    }

    if (!rules || rules.length === 0) {
      console.log(`‚ÑπÔ∏è No dealer notification rules configured for ${module}/${eventType}`);
      console.log(`‚úÖ All ${users.length} users pass through (no rules to apply)`);
      return users;
    }

    console.log(`üìú Found ${rules.length} dealer notification rule(s)`);

    const matchingRule = findMatchingRule(
      rules as DealerNotificationRule[],
      module,
      eventType,
      eventData
    );

    if (!matchingRule) {
      console.log(`‚ÑπÔ∏è No rules match the current event conditions`);
      console.log(`‚úÖ All ${users.length} users pass through (conditions not met)`);
      return users;
    }

    console.log(`‚úÖ Applying dealer rule: "${matchingRule.rule_name}" (priority: ${matchingRule.priority})`);

    const usersWithRoleInfo = users.map(user => ({
      id: user.id,
      role_name: user.role_name,
      is_assigned: false
    }));

    const evaluation = evaluateNotificationRule(
      matchingRule,
      usersWithRoleInfo,
      'sms',
      eventData
    );

    if (!evaluation.shouldSend) {
      console.log(`‚ùå Dealer rule blocked SMS notification (channel not enabled or all users filtered)`);
      console.log(`‚ö†Ô∏è ${users.length} users ‚Üí 0 users after dealer rule`);
      return [];
    }

    const filteredUserIds = new Set(evaluation.filteredUsers.map(u => u.id));
    const filteredUsers = users.filter(user => filteredUserIds.has(user.id));

    console.log(`‚úÖ Dealer rule applied: ${users.length} users ‚Üí ${filteredUsers.length} users`);

    if (filteredUsers.length < users.length) {
      const removed = users.filter(u => !filteredUserIds.has(u.id));
      console.log(`‚ùå Filtered out by dealer rule:`, removed.map(u => u.name));
    }

    return filteredUsers;

  } catch (error: any) {
    console.error(`üö® Unexpected error in dealer rules (continuing without rules):`, error.message);
    console.log(`‚úÖ Fail-safe: All ${users.length} users pass through due to error`);
    return users;
  }
}

async function checkRateLimits(
  users: SMSRecipient[],
  dealerId: number,
  module: string
): Promise<SMSRecipient[]> {
  const now = new Date();
  const hourAgo = new Date(now.getTime() - 60 * 60 * 1000);
  const today = now.toISOString().split('T')[0];

  const eligible: SMSRecipient[] = [];

  for (const user of users) {
    const { data: prefs } = await supabase
      .from('user_sms_notification_preferences')
      .select('max_sms_per_hour, max_sms_per_day, quiet_hours_enabled, quiet_hours_start, quiet_hours_end')
      .eq('user_id', user.id)
      .eq('dealer_id', dealerId)
      .eq('module', module)
      .single();

    if (!prefs) {
      console.log(`‚ö†Ô∏è No preferences found for user ${user.id}, skipping`);
      continue;
    }

    const maxPerHour = prefs.max_sms_per_hour || 10;
    const maxPerDay = prefs.max_sms_per_day || 50;

    if (prefs.quiet_hours_enabled) {
      const currentHour = now.getHours();
      const currentMinute = now.getMinutes();
      const currentTimeMinutes = currentHour * 60 + currentMinute;

      const [quietStartHour, quietStartMin] = (prefs.quiet_hours_start || '22:00').split(':').map(Number);
      const [quietEndHour, quietEndMin] = (prefs.quiet_hours_end || '08:00').split(':').map(Number);
      const quietStartMinutes = quietStartHour * 60 + quietStartMin;
      const quietEndMinutes = quietEndHour * 60 + quietEndMin;

      const isInQuietHours = quietStartMinutes > quietEndMinutes
        ? (currentTimeMinutes >= quietStartMinutes || currentTimeMinutes <= quietEndMinutes)
        : (currentTimeMinutes >= quietStartMinutes && currentTimeMinutes <= quietEndMinutes);

      if (isInQuietHours) {
        console.log(`üåô User ${user.id} is in quiet hours, skipping`);
        continue;
      }
    }

    const { count: hourCount } = await supabase
      .from('sms_send_history')
      .select('*', { count: 'exact', head: true })
      .eq('user_id', user.id)
      .eq('dealer_id', dealerId)
      .gte('sent_at', hourAgo.toISOString())
      .in('status', ['sent', 'delivered']);

    if (hourCount && hourCount >= maxPerHour) {
      console.log(`‚è±Ô∏è User ${user.id} hit hourly limit (${hourCount}/${maxPerHour})`);
      continue;
    }

    const { count: dayCount } = await supabase
      .from('sms_send_history')
      .select('*', { count: 'exact', head: true })
      .eq('user_id', user.id)
      .eq('dealer_id', dealerId)
      .eq('sent_day', today)
      .in('status', ['sent', 'delivered']);

    if (dayCount && dayCount >= maxPerDay) {
      console.log(`üìÖ User ${user.id} hit daily limit (${dayCount}/${maxPerDay})`);
      continue;
    }

    eligible.push(user);
  }

  return eligible;
}

function formatStatus(status: string): string {
  if (!status) return '';
  return status
    .split('_')
    .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
    .join(' ');
}

function generateMessages(
  users: SMSRecipient[],
  eventType: OrderSMSEvent,
  eventData: any
): Array<{ user: SMSRecipient; message: string }> {
  const shortLink = eventData.shortLink || `https://app.mydetailarea.com/orders/${eventData.orderNumber}`;

  let orderIdentifier = `#${eventData.orderNumber}`;
  if (eventData.stockNumber) {
    orderIdentifier = `#${eventData.orderNumber} (Stock: ${eventData.stockNumber})`;
  } else if (eventData.tag) {
    orderIdentifier = `#${eventData.orderNumber} (Tag: ${eventData.tag})`;
  }

  const formattedStatus = formatStatus(eventData.newStatus || '');

  let createdDetails = '';
  if (eventType === 'order_created') {
    if (eventData.vehicleInfo && eventData.vehicleInfo.trim()) {
      createdDetails += ` ${eventData.vehicleInfo}`;
    }
    if (eventData.services && eventData.services.trim()) {
      createdDetails += ` - ${eventData.services}`;
    }
    if (eventData.dueDateTime) {
      const dueDate = new Date(eventData.dueDateTime);
      const dueStr = dueDate.toLocaleString('en-US', {
        month: 'short',
        day: 'numeric',
        hour: 'numeric',
        minute: '2-digit',
        hour12: true
      });
      createdDetails += ` | Due: ${dueStr}`;
    }
  }

  const templates: Record<OrderSMSEvent, string> = {
    order_assigned: `üöó You've been assigned to Order ${orderIdentifier}.${eventData.vehicleInfo ? ` ${eventData.vehicleInfo}` : ''} View: ${shortLink}`,
    status_changed: `üìã Order ${orderIdentifier} status changed to "${formattedStatus}". View: ${shortLink}`,
    comment_added: `üí¨ ${eventData.commenterName} commented on Order ${orderIdentifier}: "${(eventData.commentText || '').substring(0, 50)}${(eventData.commentText || '').length > 50 ? '...' : ''}" View: ${shortLink}`,
    due_date_approaching: `‚è∞ REMINDER: Order ${orderIdentifier} is due in ${eventData.minutesUntilDue || 30} minutes!${eventData.vehicleInfo ? ` ${eventData.vehicleInfo}` : ''} View: ${shortLink}`,
    overdue: `üö® Order ${orderIdentifier} is OVERDUE! Please update status. View: ${shortLink}`,
    priority_changed: `‚ö° Order ${orderIdentifier} priority changed to ${eventData.newPriority || 'high'}. Check details: ${shortLink}`,
    attachment_added: `üìé New attachment added to Order ${orderIdentifier}. View: ${shortLink}`,
    order_created: createdDetails
      ? `‚ú® New Order ${orderIdentifier} -${createdDetails} View: ${shortLink}`
      : `‚ú® New Order ${orderIdentifier} created. View: ${shortLink}`,
    follower_added: `üëÅÔ∏è You're now following Order ${orderIdentifier}. View: ${shortLink}`,
    field_updated: `‚úèÔ∏è Order ${orderIdentifier} - ${eventData.fieldName} updated. View: ${shortLink}`
  };

  const message = templates[eventType] || `Order ${orderIdentifier} updated. View: ${shortLink}`;
  return users.map(user => ({ user, message }));
}

async function sendSMS(
  phoneNumber: string,
  message: string,
  orderId: string
): Promise<{ sid: string; status: string }> {
  const twilioUrl = `https://api.twilio.com/2010-04-01/Accounts/${twilioAccountSid}/Messages.json`;

  const body = new URLSearchParams({
    To: phoneNumber,
    From: twilioPhoneNumber!,
    Body: message
  });

  const response = await fetch(twilioUrl, {
    method: 'POST',
    headers: {
      'Authorization': `Basic ${btoa(`${twilioAccountSid}:${twilioAuthToken}`)}`,
      'Content-Type': 'application/x-www-form-urlencoded',
    },
    body: body.toString(),
  });

  if (!response.ok) {
    const errorData = await response.text();
    throw new Error(`Twilio API error: ${response.status} - ${errorData}`);
  }

  const result = await response.json();
  return { sid: result.sid, status: result.status };
}

async function recordSMSHistory(
  results: PromiseSettledResult<any>[],
  users: SMSRecipient[],
  messages: Array<{ user: SMSRecipient; message: string }>,
  dealerId: number,
  module: string,
  eventType: OrderSMSEvent,
  entityId: string
): Promise<void> {
  const records = results.map((result, index) => {
    const user = users[index];
    const message = messages[index];

    if (result.status === 'fulfilled') {
      return {
        user_id: user.id,
        dealer_id: dealerId,
        module,
        event_type: eventType,
        entity_id: entityId,
        phone_number: user.phone_number,
        message_content: message.message,
        twilio_sid: result.value.sid,
        status: 'sent',
        sent_day: new Date().toISOString().split('T')[0],
        cost_cents: 7
      };
    } else {
      return {
        user_id: user.id,
        dealer_id: dealerId,
        module,
        event_type: eventType,
        entity_id: entityId,
        phone_number: user.phone_number,
        message_content: message.message,
        status: 'failed',
        sent_day: new Date().toISOString().split('T')[0],
        error_message: result.reason?.message || 'Unknown error'
      };
    }
  });

  const { error } = await supabase
    .from('sms_send_history')
    .insert(records);

  if (error) {
    console.error('Error recording SMS history:', error);
  }
}

serve(handler);
